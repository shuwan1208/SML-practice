(* 示例：Standard ML 中的八皇后谜题
*)

val N = 8

(* 我们使用 8 个整数的元组来表示棋盘。
   在 SML 中，元组的索引从 1 开始 (使用 #1, #2, ... 访问)。
*)
type int8 = int * int * int * int * int * int * int * int

(* 打印点号以可视化棋盘 *)
fun print_dots (i: int): unit =
    if i > 0 then (print ". "; print_dots (i - 1))
    else ()

(* 打印棋盘的一行 *)
fun print_row (i: int): unit =
    (
        print_dots i; 
        print "Q "; 
        print_dots (N - i - 1); 
        print "\n"
    )

(* 打印整个棋盘 *)
fun print_board (bd: int8): unit =
    (
        print_row (#1 bd); print_row (#2 bd); print_row (#3 bd); print_row (#4 bd);
        print_row (#5 bd); print_row (#6 bd); print_row (#7 bd); print_row (#8 bd);
        print "\n"
    )

(* 获取第 i 行皇后的列位置 *)
fun board_get (bd: int8, i: int): int =
    case i of
      0 => #1 bd | 1 => #2 bd | 2 => #3 bd | 3 => #4 bd
    | 4 => #5 bd | 5 => #6 bd | 6 => #7 bd | 7 => #8 bd
    | _ => ~1

(* 设置第 i 行皇后的列位置为 j。
   返回一个新的棋盘元组。
*)
fun board_set (bd: int8, i: int, j: int): int8 =
    let
        val (x0, x1, x2, x3, x4, x5, x6, x7) = bd
    in
        case i of
          0 => (j, x1, x2, x3, x4, x5, x6, x7)
        | 1 => (x0, j, x2, x3, x4, x5, x6, x7)
        | 2 => (x0, x1, j, x3, x4, x5, x6, x7)
        | 3 => (x0, x1, x2, j, x4, x5, x6, x7)
        | 4 => (x0, x1, x2, x3, j, x5, x6, x7)
        | 5 => (x0, x1, x2, x3, x4, j, x6, x7)
        | 6 => (x0, x1, x2, x3, x4, x5, j, x7)
        | 7 => (x0, x1, x2, x3, x4, x5, x6, j)
        | _ => bd
    end

(* 检查位于 (i0, j0) 的皇后是否会攻击位于 (i1, j1) 的皇后 *)
fun safety_test1 (i0: int, j0: int, i1: int, j1: int): bool =
    j0 <> j1 andalso abs (i0 - i1) <> abs (j0 - j1)

(* 检查位于 (i0, j0) 的皇后相对于第 0 行到第 i 行已放置的所有皇后是否安全。
*)
fun safety_test2 (i0: int, j0: int, bd: int8, i: int): bool =
    if i >= 0 then
        if safety_test1 (i0, j0, i, board_get (bd, i)) then
            safety_test2 (i0, j0, bd, i - 1)
        else false
    else true

(* 主搜索函数 *)
fun search (bd: int8, i: int, j: int, nsol: int): int =
    if j < N then
        let
            (* 检查在 (i, j) 放置皇后是否安全 *)
            val test = safety_test2 (i, j, bd, i - 1)
        in
            if test then
                let
                    val bd1 = board_set (bd, i, j)
                in
                    if i + 1 = N then
                        let
                            val () = print ("Solution #" ^ Int.toString(nsol + 1) ^ ":\n\n")
                            val () = print_board bd1
                        in
                            search (bd, i, j + 1, nsol + 1)
                        end
                    else
                        (* 移动到下一行 (i+1)，从第 0 列开始 *)
                        search (bd1, i + 1, 0, nsol)
                end
            else
                (* 当前位置不安全，尝试下一列 (j+1) *)
                search (bd, i, j + 1, nsol)
        end
    else
        (* 回溯：如果这一行的所有列都尝试过了 *)
        if i > 0 then
            (* 回到上一行 (i-1)，尝试下一列 *)
            search (bd, i - 1, board_get(bd, i - 1) + 1, nsol)
        else 
            nsol

(* 运行求解器 *)
val initial_board = (0,0,0,0,0,0,0,0)
val total_solutions = search (initial_board, 0, 0, 0)